import xml.etree.ElementTree as ET
import librosa
import numpy as np
import sys
from datetime import datetime
import logging
import psycopg2
from constants import notes, params
from functions import is_slice_in_list, extract, printTime, findNotes, generateFingerprint, finger_to_str, datasplitter

audio_path = str(sys.argv[1])
now = datetime.now()
current_time = now.strftime("%d%m%Y %H%M%S")
logging.basicConfig(filename=str(current_time)+".log", level=logging.INFO)  # A log file is generated for every search to track the durations and errors.
logging.info(" File: "+audio_path)                      # Every occurrence of "logging.info" in this file is to log certain information.
logging.info(printTime(" Beginning: "))                 # The beginning time is logged


#no arguments, queries the whole database.
def query_database():
    try:    #Kept in this file to enable specialized tweaking of the query in the future.
        conn = psycopg2.connect(params)
        cur = conn.cursor()
        query = "SELECT id, primnote, secnote, freqval, firstnotes, name, artist FROM songsnonpattern"
        cur.execute(query)
        return cur.fetchall()
    except (Exception, psycopg2.DatabaseError) as error:
        print(error)
        logging.error(printTime(" Error: ")+error)    # The error and its time is logged
        return None
    finally:
        if conn is not None:
            conn.close()

#rows: list containing every entry in the database, entries are formatted the same way they are in the database as a list of length 7.
#fingerprint: 2 dimensional array containing the list representing every frame wherein the frequency value, the primary note and the secondary note are stored.
def survey_database(rows, fingerprint):
    
    matchfound=False
    for i in rows:                                              # This piece of code eliminates entries that have an initial sequence of primary notes that is not included
                                                                # in the input to this file. Essentially, if the first n (subject to change) primary notes from a 
                                                                # database entry is not contained within the input (wav addressed by audio_path), chances are high
                                                                # that the entry will not match the audio input. The aim here is efficiency. 
        if finger_to_str(fingerprint)[1].find(i[4]) == -1:
            rows.remove(i)

    for iii in range(0, len(rows)):      # This piece of code goes through every entry to find the highest match. In doing that, the score for every position in the fingerprint is evaluated
                                         # and the highest is considered for that particular database entry.
       
        primnotes = datasplitter(rows[iii][1])
        secnotes = datasplitter(rows[iii][2])
        freqval = datasplitter(rows[iii][3])
        scores = []
        length = 0
        if(len(fingerprint) > len(primnotes)):    # If the input is shorter than the database entry, the input is compared against every possible starting position in the entry
                                                  # and the following sequence thereafter. If the entry is shorter than the input, the opposite is done.
            length = len(primnotes)
            for i in range(0, len(fingerprint)-length+1):
                scores.append(0)
                for ii in range(0, length):
                    if (str(fingerprint[i+ii][0]) == freqval[ii]):
                        scores[i] += 1
                    if (fingerprint[i+ii][1] == primnotes[ii]):      # The scores are simply the weighting factors.
                        scores[i] += 5
                    if (fingerprint[i+ii][2] == secnotes[ii]):
                        scores[i] += 2
        elif(len(fingerprint)) <= len((primnotes)):
            length = len(fingerprint)                                           # To not calculate the list length in every iteration of the for loop below.
            for i in range(0, len((primnotes))-length+1):
                scores.append(0)
                for ii in range(0, length):
                    if ((freqval[i+ii] == str(fingerprint[ii][0]))):
                        scores[i] += 1
                    if ((primnotes[i+ii] == fingerprint[ii][1])):
                        scores[i] += 5
                    if (secnotes[i+ii] == fingerprint[ii][2]):
                        scores[i] += 2

         

        highestmatch = 0
        for i in range(0, len(scores)):
            if(scores[i] > scores[highestmatch]):       # The highest score generated by a starting position in the database entry is considered to be the score of the entry.
                highestmatch = i
        if scores[highestmatch]/(length*8)*100 > 37.49:                ## Score is turned into a percentage value and compared with the threshold for a match. The conversion to percentage is for clarity,  
                                                                        # since it involves only a handful of operations its effect on efficiency is dismissable.
                                                                        # Upon finding a match, the search is finalized.
            print("A match has been found. \nid: "+str(rows[iii][0])+"\nname: "+str(rows[iii][5])+"\nartist: "+str(rows[iii][6])+"\nmatch score(%): "+str(scores[highestmatch]/(length*8)*100))
            matchfound=True
            logging.info(printTime(" Matching complete: ")) 
            sys.exit()
            

    if not matchfound:
        print("No match was found.")
    logging.info(printTime(" Matching complete: "))  # The completion time is logged

#--------

try:
    x, sr = librosa.load(audio_path, sr=16000)
except (Exception) as error:
    print(error) 
Nfft = 4096
y = librosa.fft_frequencies(sr=sr, n_fft=Nfft)

X = librosa.stft(x, n_fft=Nfft)
Xdb = librosa.amplitude_to_db(abs(X))

chromaList = extract( Xdb, y, notes)

logging.info(printTime(" Librosa is done: ")) #This is logged to test the speed of fingerprinting and matching rather than the fft using an external library.

primaryNotes, secondaryNotes = findNotes(chromaList)

fingerprint = generateFingerprint(primaryNotes, secondaryNotes, Xdb)

logging.info(printTime(" Fingerprint extracted: ")) #Fingerprinting time is logged to be able to view the speed of fingerprinting and searching separately. 

rows= query_database()

survey_database(rows, fingerprint)




    




# The rest is previous versions of the code, to be disregarded. Kept just in case.
#allmatches.append([scores[highestmatch], rows[iii][0]])



# holder=0
# for i in range(1, len(allmatches)):
 #   if allmatches[i][0]>allmatches[holder][0]:
  #      holder=i



# print(allmatches)
# print(allmatches[holder][1])
# print(allmatches[len(allmatches)-1][1])
